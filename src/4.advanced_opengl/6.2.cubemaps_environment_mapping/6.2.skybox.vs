#version 330 core
layout (location = 0) in vec3 aPos;

out vec3 TexCoords;

uniform mat4 projection;
uniform mat4 view;

void main()
{
    TexCoords = aPos;
    vec4 pos = projection * view * vec4(aPos, 1.0);
    // 在坐标系统小节中我们说过，透视除法是在顶点着色器运行之后执行的，将gl_Position的xyz坐标除以w分量。
    // 我们又从深度测试小节中知道，相除结果的z分量等于顶点的深度值。
    // 使用这些信息，我们可以将输出位置的z分量等于它的w分量，让z分量永远等于1.0，这样子的话，当透视除法执行之后，z分量会变为w / w = 1.0。
    // pos.xyww 表示透视除法，gl_position各个坐标都会除以w.则w归一化为1.0.而z（深度值）变成了1.0;
    // 这一步的目的是，在渲染天空盒的时候，始终让天空盒的深度值为1
    gl_Position = pos.xyww;
}

// 目前我们是首先渲染天空盒，之后再渲染场景中的其它物体。这样子能够工作，但不是非常高效。
// 如果我们先渲染天空盒，我们就会对屏幕上的每一个像素运行一遍片段着色器，即便只有一小部分的天空盒最终是可见的。
// 可以使用提前深度测试(Early Depth Testing)轻松丢弃掉的片段能够节省我们很多宝贵的带宽。

// 所以，我们将会最后渲染天空盒，以获得轻微的性能提升。这样子的话，深度缓冲就会填充满所有物体的深度值了，
// 我们只需要在提前深度测试通过的地方渲染天空盒的片段就可以了，很大程度上减少了片段着色器的调用。
// 问题是，天空盒只是一个1x1x1的立方体，它很可能会不通过大部分的深度测试（为什么？？？？），导致渲染失败。不用深度测试来进行渲染不是解决方案，
// 因为天空盒将会复写场景中的其它物体。我们需要欺骗深度缓冲，让它认为天空盒有着最大的深度值1.0，只要它前面有一个物体，深度测试就会失败。